---
title: "Load ~ brightness"
---

```{r}
library(dplyr)
library(ggplot2)# Load the ape package
library(ape)
library(readxl)
library(tidyr)
library(ggpubr)
library(ade4)
library(vegan)
library(stringr)
library(brms)
library(dplyr)
library(tidyverse)
library(cmdstanr)
library(bayesplot)
library(tidybayes)
library(posterior)

```

```{r}
my_theme<-theme(axis.text=element_text(size=12),
        axis.title = element_text(size = 14),
        legend.text=element_text(size=10),
        legend.title = element_text(size=12),
        plot.title = element_text(face="bold",size=14,margin=margin(0,0,20,0),hjust = 0.5),
        axis.title.y = element_text(hjust = 0.5),
        axis.title.x = element_text(hjust = 0.5))
```


# Load dataset


```{r}
df_load <- read_excel("04april24_datalab.xlsx", sheet = 3)
df_load$nematode_count[which(df_load$nematode_count == ">100")] <- "100"
df_load$nematode_count <- as.numeric(df_load$nematode_count)

df_load <- df_load %>% 
  select(id, spp, nematode_count) %>% 
  rename(species = spp)

df_load
```



### df mean load


```{r}

df_meanload <- df_load %>%
  group_by(species) %>%
  summarise(n = n(),
            mean_load = mean(nematode_count, na.rm = TRUE),
            sd_load = sd(nematode_count, na.rm = TRUE)) %>%
  arrange(desc(mean_load))

colnames(df_meanload) = c("species", "n" ,"mean_load", "sd_load")

df_totals <- data.frame("n" = sum(df_meanload$n),
           "mean_load" = mean(df_meanload$mean_load),
           "sd_load" = mean(df_meanload$sd_load))

df_meanload <- bind_rows(df_meanload, df_totals)

df_meanload$mean_load <- round(df_meanload$mean_load, 1)
df_meanload$sd_load <- round(df_meanload$sd_load, 1)

df_meanload

#write.csv(df_load, "output/df_load.csv")

```



# brightness data

```{r}
df_kraemer <- read.csv("kraemer2019/kraemer2019_brightness_scores.csv")

df_kraemer <- df_kraemer %>% 
  select(location, spp, brightness) %>% 
  rename(id = location,
         species = spp)

df_kraemer

```


Names checks

```{r}
df_kraemer[which(df_kraemer$species == "albermarlensis"),"species"] <- "albemarlensis"
df_kraemer[which(df_kraemer$species == "cf. albemarlensis"),"species"] <- "albemarlensis"

df_kraemer[which(df_kraemer$species == "ustulatus pallescens"),"species"] <- "ustulatus"
df_kraemer[which(df_kraemer$species == "ustulatus phlegonis"),"species"] <- "ustulatus"
df_kraemer[which(df_kraemer$species == "ustulatus mahogany"),"species"] <- "ustulatus"

df_kraemer[which(df_kraemer$species == "invalidus 1"),"species"] <- "invalidus"
df_kraemer[which(df_kraemer$species == "invalidus 2"),"species"] <- "invalidus"

df_kraemer[which(df_kraemer$species == "sculpturatus 1"),"species"] <- "sculpturatus"
df_kraemer[which(df_kraemer$species == "sculpturatus 2"),"species"] <- "sculpturatus"
df_kraemer[which(df_kraemer$species == "sculpturatus 3"),"species"] <- "sculpturatus"

df_kraemer[which(df_kraemer$species == "wolfi 1"),"species"] <- "wolfi"
df_kraemer[which(df_kraemer$species == "wolfi 2"),"species"] <- "wolfi"
df_kraemer[which(df_kraemer$species == "wolfi 3"),"species"] <- "wolfi"

df_kraemer[which(df_kraemer$species == "cf. perspectivus"),"species"] <- "perspectivus"
df_kraemer[which(df_kraemer$species == "perspectivus 1"),"species"] <- "perspectivus"
df_kraemer[which(df_kraemer$species == "perspectivus 2"),"species"] <- "perspectivus"

df_kraemer[which(df_kraemer$species == "cf. amastroides"),"species"] <- "amastroides"

df_kraemer[which(df_kraemer$species == "canaliferus 1"),"species"] <- "canaliferus"
df_kraemer[which(df_kraemer$species == "canaliferus 2"),"species"] <- "canaliferus"

df_kraemer[which(df_kraemer$species == "simrothi 1"),"species"] <- "simrothi"
df_kraemer[which(df_kraemer$species == "simrothi 2"),"species"] <- "simrothi"

df_kraemer[which(df_kraemer$species == "cf. tortuganus"),"species"] <- "tortuganus"

df_kraemer[which(df_kraemer$species == "cf. nux"),"species"] <- "nux"
```


Only keep species with assessed load:

```{r}

df_kraemer1 <- df_kraemer

# df_kraemer df_merged to only include species that appear in df_load
df_kraemer <- df_kraemer %>%
  semi_join(df_load, by = "species")

df_kraemer
```



### Create common species code to make sure species names coincide

```{r}

# Combine unique species from both dataframes
unique_species <- unique(c(unique(df_load$species), unique(df_kraemer$species)))

# Create a dictionary of species to letters
species_to_number <- setNames(1:length(unique_species), unique_species)

# Add the letter codes to df_load and df_habitat
df_load$species_code <- species_to_number[df_load$species]
df_kraemer$species_code <- species_to_number[df_kraemer$species]


df_load
df_kraemer

#write_rds(df_load, "output/df_load.rds")
#write_rds(df_kraemer, "output/df_kraemer.rds")
#write_rds(df_meanload, "output/df_meanload.rds")

df_load <- readRDS("output/df_load.rds")
df_kraemer <- readRDS("output/df_kraemer.rds")
df_meanload <- readRDS("output/df_meanload.rds")

```




Check brightness data

```{r}

ggplot(data = df_kraemer, aes(x = species, y = brightness))+
  geom_point(position = position_jitter(width =.1))

```



# MODEL STAN: load ~ brightness


**NEXT STEPS**

- center brightness so that the intercept makes sense
- Try opposite constrain on the slope (setting upper = 0 instead or lower = 0) to try assuming a negative slope
- Do generated quantities also for brightness
- Conduct posterior checks on the different models (let's focus on the different + or - slope options for the last model version)


```{r}

# Prepare the data list
data_list <- list(
  N_nem = nrow(df_load),
  N_bright = nrow(df_kraemer),
  N_sp_nem = length(unique(df_load$species)),
  N_sp_bright = length(unique(df_kraemer$species)),
  load = df_load$nematode_count,
  brightness = df_kraemer$brightness,
  species_i = df_load$species_code,
  species_k = df_kraemer$species_code
)


```


## basic model

```{r}
# Fit the model using cmdstanr
stan_load_brightness <- cmdstan_model(
  stan_file = "load_brightness_map.stan", 
  pedantic = TRUE
)

fit <- stan_load_brightness$sample(
  data = data_list,
  seed = 123,             
  chains = 4,               
  parallel_chains = 4,    
  iter_warmup = 1000,       
  iter_sampling = 2000   
)

```



## model with log transformed brightness

```{r}

# Fit the model using cmdstanr
stan_load_logbrightness <- cmdstan_model(
  stan_file = "load_logbrightness.stan", 
  pedantic = TRUE
)

fit <- stan_load_logbrightness$sample(
  data = data_list,
  seed = 123,             
  chains = 4,               
  parallel_chains = 4,    
  iter_warmup = 1000,       
  iter_sampling = 2000   
)

```


## only model brightness

```{r}

# Fit the model using cmdstanr
stan_load_brightness <- cmdstan_model(
  stan_file = "brightness.stan", 
  pedantic = TRUE
)

fit <- stan_load_brightness$sample(
  data = data_list,
  seed = 123,             
  chains = 4,               
  parallel_chains = 4,    
  iter_warmup = 1000,       
  iter_sampling = 2000   
)


```


## model with log brightness and slope assumed positive

```{r}

# Fit the model using cmdstanr
stan_load_brightness <- cmdstan_model(
  stan_file = "stan/load_logbrightness_halfnormalslope.stan", 
  pedantic = TRUE
)

fit <- stan_load_brightness$sample(
  data = data_list,
  seed = 123,             
  chains = 4,               
  parallel_chains = 4,    
  iter_warmup = 1000,       
  iter_sampling = 2000   
)

```


## model with log brightness and slope assumed positive

-> Truncation can't be done in poisson_log

```{r}

# Fit the model using cmdstanr
stan_load_brightness <- cmdstan_model(
  stan_file = "stan/logbright_posslope.stan", 
  pedantic = TRUE
)

fit <- stan_load_brightness$sample(
  data = data_list,
  seed = 123,             
  chains = 4,               
  parallel_chains = 4,    
  iter_warmup = 1000,       
  iter_sampling = 2000   
)

```


## model with log brightness and slope assumed negative 



```{r}

# Fit the model using cmdstanr
stan_load_brightness <- cmdstan_model(
  stan_file = "stan/logbright_negslope.stan", 
  pedantic = TRUE
)

fit <- stan_load_brightness$sample(
  data = data_list,
  seed = 123,             
  chains = 4,               
  parallel_chains = 4,    
  iter_warmup = 1000,       
  iter_sampling = 2000   
)

```


---------------------------------------


# Model only set of species with brightness data



```{r}
df_load_filtered <- df_load %>% 
  filter(species %in% df_kraemer$species)

df_kraemer_filtered <- df_kraemer


# Combine unique species from both dataframes
unique_species <- unique(c(unique(df_load_filtered$species), unique(df_kraemer$species)))

# Create a dictionary of species to letters
species_to_number <- setNames(1:length(unique_species), unique_species)

# Add the letter codes to df_load and df_habitat
df_load_filtered$species_code <- species_to_number[df_load_filtered$species]
df_kraemer_filtered$species_code <- species_to_number[df_kraemer$species]
```





```{r}

# Prepare the data list
data_list <- list(
  N_nem = nrow(df_load_filtered),
  N_bright = nrow(df_kraemer_filtered),
  N_sp_nem = length(unique(df_load_filtered$species)),
  N_sp_bright = length(unique(df_kraemer_filtered$species)),
  load = df_load_filtered$nematode_count,
  brightness = df_kraemer_filtered$brightness,
  species_i = df_load_filtered$species_code,
  species_k = df_kraemer_filtered$species_code

)

```




```{r}
# Fit the model using cmdstanr
stan_load_brightness <- cmdstan_model(
  stan_file = "logbright_23spp.stan", 
  pedantic = TRUE
)

fit <- stan_load_brightness$sample(
  data = data_list,
  seed = 123,             
  chains = 4,               
  parallel_chains = 4,    
  iter_warmup = 1000,       
  iter_sampling = 2000   
)

```




# Plotting results



## Posterior vs predicted

```{r}
stan_load_brightness |> tidybayes::gather_rvars(predicted_load[i])
```


## All posterior pars

```{r}
# Extract the posterior samples
posterior_samples <- fit$draws()

# Convert to a data frame for easier handling
posterior_df <- as_draws_df(posterior_samples)

# Rename mu_bright parameters for easier handling
posterior_df <- posterior_df %>%
  rename_with(~ gsub("\\[|\\]", "", .), starts_with("mu_bright")) %>%
  rename_with(~ gsub("\\.", "_", .), starts_with("mu_bright"))

# Extract the names of the parameters of interest
mu_bright_names <- grep("^mu_bright", names(posterior_df), value = TRUE)
sigma_bright_names <- grep("^sigma_bright", names(posterior_df), value = TRUE)

parameter_names <- c("intercept", "slope_bright", mu_bright_names, sigma_bright_names)
```


```{r}
# Plot posterior distributions of the parameters
mcmc_areas(
  posterior_df,
  pars = parameter_names,
  prob = 0.8  # 80% intervals
)+
  coord_cartesian(xlim=c(-2,11))


```




### Posterior brightness slope

```{r}
# Extract the posterior samples of the slope of brightness
slope_samples <- fit$draws("slope_bright")

# Plot the posterior distribution of the slope of brightness
mcmc_hist(slope_samples, prob = 0.8)

```



```{r}
draws <- fit$draws(format = "df")

library(ggdist)

draws |>
  ggplot(aes(x=slope_bright)) + 
  stat_dotsinterval() + 
  xlim(c(-3,2.5))
```




```{r}
fit$draws(variables = c("intercept", "slope_bright")) |>
  posterior::summarise_draws("mean", "sd", ~quantile(.x, probs = c(0.05, 0.95)), "rhat") #|>
  #flextable::flextable()
```


### Plot for predicted values


```{r}

# Extract the predicted values from the Stan fit object
predicted_brightness <- fit$draws("predicted_brightness")
predicted_load <- fit$draws("predicted_load")

# Convert the extracted predictions to a format suitable for bayesplot
predicted_load <- as_draws_matrix(predicted_load)
predicted_brightness <- as_draws_matrix(predicted_brightness)

# Posterior predictive check for nematode load
ppc_load <- ppc_load <- ppc_dens_overlay(y = df_load$nematode_count, yrep = predicted_load) +
  scale_color_manual(name = "Legend",
                     values = c("y" = "black", "yrep" = "blue"),
                     labels = c("Observed load", "Predicted load")) +
  scale_fill_manual(name = "Legend",
                    values = c("y" = "black", "yrep" = "blue"),
                    labels = c("Observed load", "Predicted load"))+
  my_theme

# Posterior predictive check for brightness
observed_brightness <- df_kraemer$brightness
ppc_brightness <- ppc_dens_overlay(y = observed_brightness, yrep = predicted_brightness) +
  scale_color_manual(name = "Legend",
                     values = c("y" = "black", "yrep" = "coral"),
                     labels = c("Observed brightness", "Predicted brightness")) +
  scale_fill_manual(name = "Legend",
                    values = c("y" = "black", "yrep" = "coral"),
                    labels = c("Observed brightness", "Predicted brightness"))+
  xlim(0,60000)
  my_theme


ppc_plots_load_bright <- ggarrange(
  
  ppc_load,
  ppc_brightness,
  labels = LETTERS[1:2],
  ncol = 1,
  nrow = 2
)

ppc_plots_load_bright

ggsave("figures/ppc_load_bright_neg.png", height = 10, width = 15)

```


```{r}
# Compute mean observed nematode load per species
mean_observed_load <- df_load %>%
  group_by(species_code) %>%
  summarise(mean_load = mean(nematode_count, na.rm = TRUE))

# Reshape predicted_load to have species_code as one of the columns
predicted_load_df <- as.data.frame(predicted_load)
predicted_load_df <- predicted_load_df %>%
  pivot_longer(cols = everything(), names_to = "draw", values_to = "predicted_load")

# Assume species_code is correctly ordered and repeated for each draw
species_codes <- rep(df_load$species_code, each = dim(predicted_load)[1] / length(unique(df_load$species_code)))
predicted_load_df$species_code <- species_codes

# Compute mean predicted load per species
mean_predicted_load <- predicted_load_df %>%
  group_by(species_code) %>%
  summarise(mean_predicted_load = mean(predicted_load, na.rm = TRUE))

# Merge observed and predicted means
comparison_df <- merge(mean_observed_load, mean_predicted_load, by = "species_code")

# Scatter plot of observed vs. predicted load
ggplot(comparison_df) +
  geom_point(aes(x = mean_load, y = mean_predicted_load)) +
  labs(x = "Observed Mean Nematode Load", y = "Predicted Mean Nematode Load") +
  ggtitle("Observed vs. Predicted Mean Nematode Load") +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red")  # Add a 
```







---------------------------------

### Relationship load-brightness

```{r}
# Calculate mean brightness for each species from the posterior samples
mu_bright_mean <- posterior_df %>%
  summarise(across(all_of(mu_bright_names), mean)) %>%
  unlist()

# Create a data frame with species IDs and corresponding mean brightness
brightness_df <- data.frame(
  species_id = seq_along(mu_bright_mean),
  mu_bright = mu_bright_mean
)

# Calculate the mean intercept and slope from the posterior samples
intercept_mean <- mean(posterior_df$intercept)
slope_bright_mean <- mean(posterior_df$slope_bright)

# Create a data frame with the species mean parasitic load
mean_parasitic_load <- df_load %>%
  group_by(species_code) %>%
  summarise(mean_load = mean(nematode_count))

# Merge brightness and parasitic load data frames
plot_df <- merge(brightness_df, mean_parasitic_load, by.x = "species_id", by.y = "species_code")

# Plot the relationship
ggplot(plot_df, aes(x = mu_bright, y = mean_load)) +
  geom_point() +
  geom_abline(intercept = intercept_mean, slope = slope_bright_mean, color = "blue") +
  labs(x = "Mean Brightness", y = "Mean Parasitic Load") +
  theme_minimal()



```


# MODEL STAN: load ~ brightness




```{r}
# Create a mapping between species names and new IDs for df_kraemer
kraemer_species <- unique(df_kraemer$species)
kraemer_species_map <- setNames(seq_along(kraemer_species), kraemer_species)

# Create a mapping between species names and new IDs for df_load
load_species <- unique(df_load$species)
load_species_map <- setNames(seq_along(load_species), load_species)

# Create the species_map that maps df_load species IDs to df_kraemer species IDs
species_map <- sapply(load_species, function(x) {
  if (x %in% kraemer_species) {
    kraemer_species_map[x]
  } else {
    NA
  }
})

# Remove duplicates in species_map names by stripping everything after the first dot
names(species_map) <- sub("\\..*", "", names(species_map))

# Convert species_map to integers and handle NAs
species_map_int <- ifelse(is.na(species_map), NA, species_map)

# Create the new species IDs for df_load and df_kraemer
df_load$new_species_id <- load_species_map[df_load$species]
df_kraemer$new_species_id <- kraemer_species_map[df_kraemer$species]

# Prepare the data list
data_list <- list(
  N_nem = nrow(df_load),
  N_bright = nrow(df_kraemer),
  N_sp_nem = length(unique(df_load$species)),
  N_sp_bright = length(unique(df_kraemer$species)),
  load = df_load$nematode_count,
  brightness = df_kraemer$brightness,
  species_i = df_load$new_species_id,
  species_k = df_kraemer$new_species_id,
  species_map = as.integer(species_map_int)
)







###########################################################

# Fit the model using cmdstanr
stan_load_brightness <- cmdstan_model(
  stan_file = "load_brightness_map.stan", 
  pedantic = TRUE
)

fit <- stan_load_brightness$sample(
  data = data_list,
  seed = 123,             
  chains = 4,               
  parallel_chains = 4,    
  iter_warmup = 1000,       
  iter_sampling = 2000   
)


species_map

data_list$species_k



```




previous stan code befor eAndrew

```{r}
data {
  int<lower=0> N_nem;               // Number of observations for nematode load
  int<lower=0> N_bright;            // Number of observations for brightness
  array[N_nem] int<lower=0, upper=100> load;  // Nematode load counts
  vector[N_bright] brightness;       // Brightness scores
  int<lower=0> N_sp_nem;             // Number of species in the nematode data
  int<lower=0> N_sp_bright;          // Number of species in the brightness data
  array[N_nem] int<lower=1> species_i;   // New species id for load dataset
  array[N_bright] int<lower=1> species_k; // New species id for brightness dataset
  array[N_sp_nem] int<lower=1, upper=N_sp_bright> species_map; // Mapping from nematode species to brightness species
}

parameters {
  real intercept;
  real slope_bright;
  vector[N_sp_bright] mu_bright;       // Mean brightness for each species
  vector<lower=0>[N_sp_bright] sigma_bright; // Standard deviation of brightness for each species
}

model {
  vector[N_sp_nem] lambda;
  
  // Priors
  intercept ~ normal(0, 10);
  slope_bright ~ normal(0, 1);
  mu_bright ~ normal(0, 1);
  sigma_bright ~ exponential(1);
  
  // Model brightness
  brightness ~ normal(mu_bright[species_k], sigma_bright[species_k]);
  
  // Model nematode load
  lambda = intercept + slope_bright * mu_bright[species_map[species_i]];
  load ~ poisson(lambda[species_i]);
}

generated quantities {
  
  array[N_nem] real predicted_load;  // Predicted nematode load
  
  for (n in 1:N_nem) {
    predicted_load[n] = poisson_rng(intercept + slope_bright * mu_bright[species_map[species_i[n]]]);
  }
}

```

