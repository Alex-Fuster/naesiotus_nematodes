---
title: "R Notebook"
---


The RAD sequencing showed that there are several cryptic species and the taxonomy of the group needs to be revisited.

When sampling nematode interactions in the dry collection, the snail species' names were annotated according to the classic taxonomy and doesnt follow the level of detailed differenciation reconstructed by the rad sequencing tree. 

However, for those species for which cryptic lineages are identified and now appear as different nodes in the tree, we can approximate the taxa identity that was assessed for the load based on the location of the sampled populations. I therefore discard those lineages among a cryptic species complex for which I dont measure individuals of its location (based on individuals' ID):

- **Invalidus 2**
- **Wolfi 2, Wolfi 3**
- **sculpturatus 2, sculpturatus 3**
- **Simrothi 2**

(guess) decision justified by proximity of sampling location:

- **Perspectivus**: perspectivus 1 dicarded. I only measure perspectivus from 2005 and locations SL05-01 and SL05-02. The closest to this location are cf. perspectivus and perspectivus 2, so I keep these.


A completely arbitrary decision:

- **Canaliferous**: canaliferous individuals measured are not from neither canaliferous 1 or canaliferous 2 areas, so it can be assigned to any of them. 

I need to repeat analysis with different options for the decision on canalifrous (one discarding canaliferous 1 and another canaliferous 2) to make sure it doesnt impact the overall results.


```{r setup-packages}
#| message: false
#| warning: false
library(tidyverse)
library(readxl)
library(ggpubr)
library(phytools)
library(ape)
library(ggtree)

```




# Generate tree

### tree from raw rad seq data

```{r}

#tree <- read.nexus(here::here("data/phylogeny_2024/Species_tree_labelled.nex"))
tree <- read.newick(here::here("data/phylogeny_2024/tree2024.nwk"))
df_rads <- read_excel(here::here("data/phylogeny_2024/New_tree_taxa_28Aug24.xlsx"))
species_names_df_raw <- read.csv(here::here("data/species_names_checks.csv"))

species_names_df <- species_names_df_raw %>% 
  rename(species = annotated_name)  %>% 
  filter(species_name != "")

tree_data <- fortify(tree)
ggtree(tree) +
  geom_tiplab() +  # Add tip labels for species
  theme_tree() +  # Remove legend
  xlim(0, max(tree_data$x) + 0.3)  

```


Correct typos

```{r}
tree$tip.label[which(tree$tip.label == "'sp_nov_Volc치n_Wolf_1'")]<- "sp. nov. Volcan Wolf 1"
tree$tip.label[which(tree$tip.label == "'sp_nov_Volc치n_Wolf_2'")]<- "sp. nov. Volcan Wolf 2"
tree$tip.label[which(tree$tip.label == "'sp_nov_Volc치n_Wolf_3'")]<- "sp. nov. Volcan Wolf 3"


tree$tip.label[which(tree$tip.label == "'sp_nov_pinz칩n_1'")]<- "sp. nov. pinzon 1"

#tree$tip.label <- gsub("^[\"'`]+|[\"'`]+$", "", tree$tip.label)

```



```{r}
# Create a named vector for species mapping
name_mapping <- species_names_df_raw %>%
  #filter(!is.na(species_name)) %>%
  select(annotated_name, species_name) %>%
  distinct() %>%
  deframe()  # Create a named vector with annotated_name as names and species_name as values

# Update the tree tip labels using the mapping
tree$tip.label <- sapply(tree$tip.label, function(x) {
  if (x %in% names(name_mapping)) {
    name_mapping[[x]]  # Replace with the mapped name if it exists
  } else {
    x  # Keep the original name if no mapping is found
  }
})

# Prepare data for plotting
tree_data <- fortify(tree)
tree_data$has_name <- tree_data$label %in% name_mapping  # Check if the label has a corresponding name in the mapping

# Plot the tree with conditional styling, remove the legend, and adjust plot width
p <- ggtree(tree) +
  geom_tiplab(data = tree_data, aes(label = label, 
                  fontface = ifelse(has_name, "bold", "plain"), 
                  color = ifelse(has_name, "blue", "black")), 
              size = 3, 
              align = TRUE,  # Align labels
              linetype = NA,  # Remove lines connecting labels to tree
              offset = 0.01,  # Adjust the position of the labels to avoid going out of margin
              inherit.aes = FALSE) +
  theme(legend.position = "none") +  # Remove legend
  xlim(0, max(tree_data$x) + 0.3)  # Adjust the x-axis limit to control width

print(p)
```

Prune the tree to keep only assessed species

```{r}
# Extract the species names to keep (those that have an assigned name)
species_to_keep <- tree_data$label[tree_data$has_name]

# Step 1: Filter out any empty names from species_to_keep
species_to_keep <- species_to_keep[species_to_keep != ""]

# Step 2: Prune the tree to keep only these species
pruned_tree <- drop.tip(tree, setdiff(tree$tip.label, species_to_keep))

ggtree(pruned_tree) +
  geom_tiplab(aes(label = label), size = 3) + 
  xlim(0, max(pruned_tree$edge.length) + 3)  # Adjust x-axis limits
```



```{r}
df_load_raw <- read_excel(path = here::here("data/19july24_datalab.xlsx"), sheet = 3)

df_load_raw$nematode_count[which(df_load_raw$nematode_count == ">100")] <- "100"
df_load_raw$nematode_count <- as.numeric(df_load_raw$nematode_count)

df_load_rename <- df_load_raw %>% 
  select(id, spp, nematode_count, island) %>% 
  rename(species = spp)

# correct species names
df_load <- df_load_rename %>%
  left_join(species_names_df |> select(species, species_name),
            by = "species") 
df_load
```

Compute mean and se load per species

```{r}
df_meanload <- df_load %>%
  group_by(species_name) %>%
  summarise(n = n(),
            mean_load = mean(nematode_count, na.rm = TRUE),
            se_load = sd(nematode_count, na.rm = TRUE)/sqrt(length(nematode_count)), 
            sd_load = sd(nematode_count, na.rm = TRUE)) %>%
  arrange(desc(mean_load))

df_meanload
```


```{r}
meanload<-setNames(df_meanload$mean_load, df_meanload$species_name)
s.error<-setNames(df_meanload$se_load, df_meanload$species_name)
```


discard those species in load that are not present in the tree

```{r}
# Filter data to include only species present in the phylogenetic tree
tree_species <- pruned_tree$tip.label
meanload_filtered <- meanload[names(meanload) %in% tree_species]
s.error_filtered <- s.error[names(s.error) %in% tree_species]

# Verify data alignment
match_indices <- match(tree_species, names(meanload_filtered))
meanload_filtered <- meanload_filtered[match_indices]
s.error_filtered <- s.error_filtered[match_indices]
```


# Blomberg's K

```{r}
K_nemaload <- phylosig(pruned_tree, meanload_filtered, method = 'K', test = TRUE, se = s.error_filtered)
K_nemaload
plot.phylosig(K_nemaload)

```


# Lambda

```{r}

lambda_nemaload <- phylosig(pruned_tree, meanload_filtered, method = 'lambda', test = TRUE, se = s.error_filtered) 
lambda_nemaload <- phylosig(pruned_tree, meanload_filtered, method = 'lambda', test = TRUE) 
lambda_nemaload
plot.phylosig(lambda_nemaload)

```



# Plot tree and load

```{r}

contMap(pruned_tree,
        meanload_filtered,
        res = 400,
        lwd = 4,
        outline = FALSE,
        sig = 0)

```



```{r}
# Step 1: Create a mapping of species to islands
species_island_map <- df_load %>%
  select(species_name, island) %>%
  distinct() %>%
  group_by(species_name) %>%
  summarize(island = paste(unique(island), collapse = ", "))  # Handle cases where species occur on multiple islands


tree_data1 <- fortify(pruned_tree)

# Merge the tree data with the island information
tree_data1 <- tree_data1 %>%
  left_join(species_island_map, by = c("label" = "species_name"))  # Merge based on the species names

# Create a column indicating whether each tip label has an assigned name
tree_data1$has_name <- !is.na(tree_data1$island)

# Plot the tree with conditional styling
ggtree(pruned_tree) +
  geom_tiplab(data = tree_data1, aes(label = label, 
                                    
                                    color = island),  # Use island information to color labels
              size = 3, 
              align = TRUE,  # Align labels
              linetype = NA,  # Remove lines connecting labels to tree
              offset = 0.01,  # Adjust the position of the labels to avoid going out of margin
              inherit.aes = FALSE) +
  theme(legend.position = "bottom")+  # Remove legend
  xlim(0, max(tree_data$x) + 3)  # Adjust the x-axis limit to control width   # Adjust the x-axis limit to control width

```


# Analysis with diversity


Keep species names for which nematode amplification was successful

```{r}
diversity_per_snailspp <- read.csv(here::here("output/tables/diversity_per_snailspp.csv"))[,-1]

# correct species names
diversity_per_snailspp <- diversity_per_snailspp %>%
  left_join(species_names_df |> select(species, species_name),
            by = "species") 
```


Prune the tree to keep only assessed species

```{r}
# Extract the species names to keep from your dataset
species_assessed_div <- unique(diversity_per_snailspp$species_name)

# Check which species names are not found in the tree's tip labels
mismatched_species <- setdiff(species_assessed_div, pruned_tree$tip.label)

mismatched_species
```

Filter data

```{r}
diversity_per_snailspp_filtered <- diversity_per_snailspp %>%
  filter(!(species_name %in% mismatched_species))
  
```


```{r}
div_nem_species <-setNames(diversity_per_snailspp_filtered$nematode_species, diversity_per_snailspp_filtered$species_name)

if(length(setdiff(unique(pruned_tree$tip.label),diversity_per_snailspp_filtered$species_name)) != 0){
"problem- mismatch in names"
}else{
"all good - species in data and tree match"
}

```
How to get standard error? maybe from sequence data 


# Blomberg's K

```{r}
K_nemadiv <- phylosig(pruned_tree, div_nem_species, method = 'K', test = TRUE)
K_nemadiv
plot.phylosig(K_nemadiv)

```


# Lambda

```{r}

lambda_nemadiv <- phylosig(pruned_tree, div_nem_species, method = 'lambda', test = TRUE) 
lambda_nemadiv <- phylosig(pruned_tree, div_nem_species, method = 'lambda', test = TRUE) 
lambda_nemadiv
plot.phylosig(lambda_nemadiv)

```

# Plot tree and nem diversity


```{r}
matching_species <- intersect(pruned_tree$tip.label, names(div_nem_species))

# Filter and reorder the phenotypic data to match the tree tip labels
div_nem_species_matched <- div_nem_species[matching_species]
div_nem_species_matched <- div_nem_species_matched[match(pruned_tree$tip.label, names(div_nem_species_matched))]

if (!all(names(div_nem_species_matched) == pruned_tree$tip.label)) {
  stop("Error: The names in the phenotypic data do not match the tip labels in the tree.")
}

# Use contMap to plot the tree with the matched data
contMap(pruned_tree,
        div_nem_species_matched,
        res = 400,
        lwd = 4,
        outline = FALSE,
        sig = 0)
```


--------------------------------------------------


```{r}
heatmap_data <- data.frame(
  species_name = names(div_nem_species_matched),
  div = div_nem_species_matched
)

# Aggregate the data to make species names unique
heatmap_data <- heatmap_data %>%
  group_by(species_name) %>%
  summarise(div = sum(div, na.rm = TRUE)) %>%  # Adjust to your preferred method (sum, mean, etc.)
  ungroup()

# Ensure there are no missing values
heatmap_data <- heatmap_data %>%
  filter(!is.na(div))  # Remove rows with NA values

# Set the row names to the unique species names
rownames(heatmap_data) <- heatmap_data$species_name

# Plot the tree
p <- ggtree(pruned_tree) +
  geom_tiplab(align = TRUE, linesize = 0.5, offset = 0.01) +
  xlim(0, 3)  # Adjust the x-axis limits as needed

# Add the heatmap next to the tree
p1 <- gheatmap(p, heatmap_data[, "div", drop = FALSE], offset = 0.8, width = 0.1, 
               colnames = FALSE, low = "white", high = "red", legend_title = "div") +
  scale_fill_gradient(low = "white", high = "red")  # Ensures a color gradient for the fill

# Print the plot
print(p1)
```