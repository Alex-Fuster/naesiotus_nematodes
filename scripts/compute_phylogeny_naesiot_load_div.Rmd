---
title: "R Notebook"
---


The RAD sequencing showed that there are several cryptic species and the taxonomy of the group needs to be revisited.

When sampling nematode interactions in the dry collection, the snail species' names were annotated according to the classic taxonomy and doesnt follow the level of detailed differenciation reconstructed by the rad sequencing tree. 

However, for those species for which cryptic lineages are identified and now appear as different nodes in the tree, we can approximate the taxa identity that was assessed for the load based on the location of the sampled populations. I therefore discard those lineages among a cryptic species complex for which I dont measure individuals of its location (based on individuals' ID):

- **Invalidus 2**
- **Wolfi 2, Wolfi 3**
- **sculpturatus 2, sculpturatus 3**
- **Simrothi 2**

(guess) decision justified by proximity of sampling location:

- **Perspectivus**: perspectivus 1 dicarded. I only measure perspectivus from 2005 and locations SL05-01 and SL05-02. The closest to this location are cf. perspectivus and perspectivus 2, so I keep these.


A completely arbitrary decision:

- **Canaliferous**: canaliferous individuals measured are not from neither canaliferous 1 or canaliferous 2 areas, so it can be assigned to any of them. 

I need to repeat analysis with different options for the decision on canalifrous (one discarding canaliferous 1 and another canaliferous 2) to make sure it doesnt impact the overall results.


```{r setup-packages}
#| message: false
#| warning: false
library(tidyverse)
library(readxl)
library(ggpubr)
library(phytools)
library(ape)
library(ggtree)

```




# Generate tree

### tree from raw rad seq data

```{r}

#tree <- read.nexus(here::here("data/phylogeny_2024/Species_tree_labelled.nex"))
tree <- read.newick(here::here("data/phylogeny_2024/tree2024.nwk"))
df_rads <- read_excel(here::here("data/phylogeny_2024/New_tree_taxa_28Aug24.xlsx"))
species_names_df_raw <- read.csv(here::here("data/species_names_checks.csv"))

species_names_df <- species_names_df_raw %>% 
  rename(species = annotated_name)  %>% 
  filter(species_name != "")

tree_data <- fortify(tree)
ggtree(tree) +
  geom_tiplab() +  # Add tip labels for species
  theme_tree() +  # Remove legend
  xlim(0, max(tree_data$x) + 0.3)  

```


Eliminate accents

```{r}

tree$tip.label <- gsub("'", "", tree$tip.label)
tree$tip.label[grepl("sp._nov._Volcán_Wolf_1", tree$tip.label)] <- "sp. nov. Volcan Wolf 1"
tree$tip.label[grepl("sp._nov._Volcán_Wolf_2", tree$tip.label)] <- "sp. nov. Volcan Wolf 2"
tree$tip.label[grepl("sp._nov._Volcán_Wolf_3", tree$tip.label)] <- "sp. nov. Volcan Wolf 3"
tree$tip.label[which(tree$tip.label == "sp._nov._pinzón_1")]<- "sp. nov. pinzon 1"

tree_data <- fortify(tree)
ggtree(tree) +
  geom_tiplab() +  # Add tip labels for species
  theme_tree() +  # Remove legend
  xlim(0, max(tree_data$x) + 0.3) 

```


```{r}
# Create a named vector where names are `annotated_name` and values are `species_name`
name_mapping <- setNames(species_names_df_raw$species_name, species_names_df_raw$annotated_name)

# Initialize a logical vector to track which labels were changed
changed_labels <- rep(FALSE, length(tree$tip.label))

# Loop through the tip labels and apply the conditions
tree$tip.label <- sapply(tree$tip.label, function(label) {
  if (label %in% names(name_mapping)) {
    # Get the corresponding species_name
    new_name <- name_mapping[[label]]
    
    # Condition 2: If species_name is blank, keep the current label
    if (new_name == "") {
      return(label)
    } else {
      # Condition 3: If species_name is not blank, change the label and mark it as changed
      changed_labels[tree$tip.label == label] <<- TRUE
      return(new_name)
    }
  } else {
    # Condition 1: If label is not found in annotated_name, keep the current label
    return(label)
  }
})

# Ensure tree_data is created from the tree
tree_data <- fortify(tree)

# Apply `changed_labels` only to the tips (i.e., `isTip == TRUE`)
tip_data <- tree_data %>% filter(isTip)

# Make sure `changed_labels` is only as long as the tip labels
tip_data$changed_labels <- changed_labels

# Plot the tree using only the tip data for labeling
ggtree(tree) +
  geom_tiplab(aes(label = label, color = changed_labels), data = tip_data) +  # Only apply to tips
  scale_color_manual(values = c("black", "red")) +  # Black for unchanged, red for changed
  theme_tree() +
  xlim(0, max(tree_data$x) + 0.3)  # Adjust x-axis limits if necessary



```

Tree formatting: delete duplicate names and homogenize names format

```{r}
# Identify the positions of the duplicates in the tip labels
amastroides_tips <- which(tree$tip.label == "amastroides")
perspectivus_tips <- which(tree$tip.label == "perspectivus")

# Append "delete" to one instance of each duplicated name
tree$tip.label[amastroides_tips[1]] <- "amastroidesdelete"
tree$tip.label[perspectivus_tips[1]] <- "perspectivusdelete"

# Drop the tips with "delete" in their names
tree <- drop.tip(tree, c("amastroidesdelete", "perspectivusdelete"))

# Replace underscores with hyphens (or other suitable character)
tree$tip.label <- gsub("_", "-", tree$tip.label)

# Replace periods with empty space or other suitable character
tree$tip.label <- gsub("\\.", "", tree$tip.label)

# Replace hyphens with an empty string or another suitable character
tree$tip.label <- gsub("-", "", tree$tip.label)

plot(tree)

write.tree(tree, file = here::here("BAMM/cleannames_tree_041024.txt"))
```


## Add island information

```{r}
df_load_raw <- read_excel(path = here::here("data/18sept24_datalab.xlsx"), sheet = 3)

# Join df_load_raw with species_names_df to correct species names
df_corrected <- df_load_raw %>%
  left_join(species_names_df, by = c("spp" = "species")) %>%
  # Replace spp with the corrected species_name from species_names_df
  mutate(corrected_species = species_name) %>%
  # Select relevant columns and remove duplicates
  select(corrected_species, island) %>%
  distinct()

# Rename columns for clarity
df_corrected <- df_corrected %>%
  rename(species = corrected_species)

# Filter to get only unique species-island combinations
species_island_table <- df_corrected %>%
  distinct(species, island) 

# Apply the same formatting transformations to the species names
species_island_table <- species_island_table %>%
  mutate(
    species = gsub("_", "-", species), # Replace underscores with hyphens
    species = gsub("\\.", "", species), # Remove periods
    species = gsub("-", "", species),    # Remove hyphens
     species = gsub(" ", "", species)  # Remove spaces
  )

species_island_table

```


# Plot species sampled

```{r}
# List of species to color in red (from species_island_table$species)
species_to_color <- species_island_table$species

# Plot the tree with ggtree
p <- ggtree(tree) +
  geom_tiplab(aes(label = label, color = label %in% species_to_color), 
              hjust = -0.2,          # Adjusts horizontal spacing
              size = 2.5,            # Adjusts the size of the labels
              angle = 0) +           # Rotates labels to horizontal
  scale_color_manual(values = c("TRUE" = "red", "FALSE" = "black")) +
  theme_tree2() +
  xlim(NA, max(node.depth.edgelength(tree)) * 1.2) # Extends x-axis limit for more spacing

# Display the plot
print(p)
```

# Plot island clades

```{r}

# Create a data frame from tree tip labels to use for merging
tree_data <- data.frame(label = tree$tip.label)

tree_data <- tree_data %>%
  left_join(species_island_table, by = c("label" = "species")) %>%
  mutate(island = factor(island, levels = c(unique(na.omit(island)), "Not Assigned")))

# Replace NA values in island with "Not Assigned"
tree_data$island[is.na(tree_data$island)] <- "Not Assigned"

# Define custom colors for islands, with "Not Assigned" as white
island_colors <- c(
  viridis::viridis_pal(option = "turbo")(length(unique(tree_data$island)) - 1), # Turbo colors for islands
  "white"  # White for "Not Assigned"
)
names(island_colors) <- levels(tree_data$island)

# Plot the tree with points colored by island
p <- ggtree(tree) %<+% tree_data +
  geom_tiplab(hjust = -0.2, size = 2.5) +
  geom_tippoint(aes(color = island), size = 3) +  # Adds colored points at tips based on island
  scale_color_manual(values = island_colors) +  # Apply custom color palette
  theme_tree2() +
  xlim(NA, max(node.depth.edgelength(tree)) * 1.4) + # Extend x-axis for spacing
  theme(legend.position = "right")

# Display the plot
print(p)

ggsave("tree_islandclades.png", height = 10, width = 8)
```



# combine both

```{r}

library(ggnewscale)


tree_data <- data.frame(label = tree$tip.label)

# List of species to color in red
species_to_color <- species_island_table$species

# Merge the tree data with the island information
tree_data <- tree_data %>%
  left_join(species_island_table, by = c("label" = "species")) %>%
  mutate(island = factor(island, levels = c(unique(na.omit(island)), "Not Assigned")),
         is_red = label %in% species_to_color)  # Indicates which labels should be red

# Replace NA values in island with "Not Assigned"
tree_data$island[is.na(tree_data$island)] <- "Not Assigned"

# Define custom colors for islands, with "Not Assigned" as white
island_colors <- c(
  viridis::viridis_pal(option = "turbo")(length(unique(tree_data$island)) - 1), # Turbo colors for islands
  "white"  # White for "Not Assigned"
)
names(island_colors) <- levels(tree_data$island)

# Plot the tree with red-colored tip labels and points for islands
p <- ggtree(tree) %<+% tree_data +
  geom_tiplab(aes(label = label, color = is_red), 
              hjust = -0.2, size = 2.5, show.legend = FALSE) + # Red for specific species
  scale_color_manual(values = c("TRUE" = "red", "FALSE" = "black"), guide = "none") +  # Red for matching species, black otherwise
  new_scale_color() +  # Allows separate color scale for the island points
  geom_tippoint(aes(color = island), size = 3) +  # Island-colored points
  scale_color_manual(values = island_colors, name = "Island") +  # Apply custom island color palette
  theme_tree2() +
  xlim(NA, max(node.depth.edgelength(tree)) * 1.4) + # Extend x-axis for spacing
  theme(legend.position = "right")

# Display the plot
print(p)

ggsave("tree_islandclades.png", height = 10, width = 8)
```



########################################################
########################################################
########################################################
########################################################


Prune the tree to keep only assessed species

```{r}
# Extract the species names to keep (those that have an assigned name)
species_to_keep <- tree_data$label[tree_data$has_name]

# Step 1: Filter out any empty names from species_to_keep
species_to_keep <- species_to_keep[species_to_keep != ""]

# Step 2: Prune the tree to keep only these species
pruned_tree <- drop.tip(tree, setdiff(tree$tip.label, species_to_keep))

ggtree(pruned_tree) +
  geom_tiplab(aes(label = label), size = 3) + 
  xlim(0, max(pruned_tree$edge.length) + 3)  # Adjust x-axis limits
```



```{r}
df_load_raw <- read_excel(path = here::here("data/19july24_datalab.xlsx"), sheet = 3)

df_load_raw$nematode_count[which(df_load_raw$nematode_count == ">100")] <- "100"
df_load_raw$nematode_count <- as.numeric(df_load_raw$nematode_count)

df_load_rename <- df_load_raw %>% 
  select(id, spp, nematode_count, island) %>% 
  rename(species = spp)

# correct species names
df_load <- df_load_rename %>%
  left_join(species_names_df |> select(species, species_name),
            by = "species") 
df_load
```

Compute mean and se load per species

```{r}
df_meanload <- df_load %>%
  group_by(species_name) %>%
  summarise(n = n(),
            mean_load = mean(nematode_count, na.rm = TRUE),
            se_load = sd(nematode_count, na.rm = TRUE)/sqrt(length(nematode_count)), 
            sd_load = sd(nematode_count, na.rm = TRUE)) %>%
  arrange(desc(mean_load))

df_meanload
```


```{r}
meanload<-setNames(df_meanload$mean_load, df_meanload$species_name)
s.error<-setNames(df_meanload$se_load, df_meanload$species_name)
```


discard those species in load that are not present in the tree

```{r}
# Filter data to include only species present in the phylogenetic tree
tree_species <- pruned_tree$tip.label
meanload_filtered <- meanload[names(meanload) %in% tree_species]
s.error_filtered <- s.error[names(s.error) %in% tree_species]

# Verify data alignment
match_indices <- match(tree_species, names(meanload_filtered))
meanload_filtered <- meanload_filtered[match_indices]
s.error_filtered <- s.error_filtered[match_indices]
```


# Blomberg's K

```{r}
K_nemaload <- phylosig(pruned_tree, meanload_filtered, method = 'K', test = TRUE, se = s.error_filtered)
K_nemaload
plot.phylosig(K_nemaload)

```


# Lambda

```{r}

lambda_nemaload <- phylosig(pruned_tree, meanload_filtered, method = 'lambda', test = TRUE, se = s.error_filtered) 
lambda_nemaload <- phylosig(pruned_tree, meanload_filtered, method = 'lambda', test = TRUE) 
lambda_nemaload
plot.phylosig(lambda_nemaload)

```



# Plot tree and load

```{r}

contMap(pruned_tree,
        meanload_filtered,
        res = 400,
        lwd = 4,
        outline = FALSE,
        sig = 0)

```



```{r}
# Step 1: Create a mapping of species to islands
species_island_map <- df_load %>%
  select(species_name, island) %>%
  distinct() %>%
  group_by(species_name) %>%
  summarize(island = paste(unique(island), collapse = ", "))  # Handle cases where species occur on multiple islands


tree_data1 <- fortify(pruned_tree)

# Merge the tree data with the island information
tree_data1 <- tree_data1 %>%
  left_join(species_island_map, by = c("label" = "species_name"))  # Merge based on the species names

# Create a column indicating whether each tip label has an assigned name
tree_data1$has_name <- !is.na(tree_data1$island)

# Plot the tree with conditional styling
ggtree(pruned_tree) +
  geom_tiplab(data = tree_data1, aes(label = label, 
                                    
                                    color = island),  # Use island information to color labels
              size = 3, 
              align = TRUE,  # Align labels
              linetype = NA,  # Remove lines connecting labels to tree
              offset = 0.01,  # Adjust the position of the labels to avoid going out of margin
              inherit.aes = FALSE) +
  theme(legend.position = "bottom")+  # Remove legend
  xlim(0, max(tree_data$x) + 3)  # Adjust the x-axis limit to control width   # Adjust the x-axis limit to control width

```


# Analysis with diversity


Keep species names for which nematode amplification was successful

```{r}
diversity_per_snailspp <- read.csv(here::here("output/tables/diversity_per_snailspp.csv"))[,-1]

# correct species names
diversity_per_snailspp <- diversity_per_snailspp %>%
  left_join(species_names_df |> select(species, species_name),
            by = "species") 
```


Prune the tree to keep only assessed species

```{r}
# Extract the species names to keep from your dataset
species_assessed_div <- unique(diversity_per_snailspp$species_name)

# Check which species names are not found in the tree's tip labels
mismatched_species <- setdiff(species_assessed_div, pruned_tree$tip.label)

mismatched_species
```

Filter data

```{r}
diversity_per_snailspp_filtered <- diversity_per_snailspp %>%
  filter(!(species_name %in% mismatched_species))
  
```


```{r}
div_nem_species <-setNames(diversity_per_snailspp_filtered$nematode_species, diversity_per_snailspp_filtered$species_name)

if(length(setdiff(unique(pruned_tree$tip.label),diversity_per_snailspp_filtered$species_name)) != 0){
"problem- mismatch in names"
}else{
"all good - species in data and tree match"
}

```
How to get standard error? maybe from sequence data 


# Blomberg's K

```{r}
K_nemadiv <- phylosig(pruned_tree, div_nem_species, method = 'K', test = TRUE)
K_nemadiv
plot.phylosig(K_nemadiv)

```


# Lambda

```{r}

lambda_nemadiv <- phylosig(pruned_tree, div_nem_species, method = 'lambda', test = TRUE) 
lambda_nemadiv <- phylosig(pruned_tree, div_nem_species, method = 'lambda', test = TRUE) 
lambda_nemadiv
plot.phylosig(lambda_nemadiv)

```

# Plot tree and nem diversity


```{r}
matching_species <- intersect(pruned_tree$tip.label, names(div_nem_species))

# Filter and reorder the phenotypic data to match the tree tip labels
div_nem_species_matched <- div_nem_species[matching_species]
div_nem_species_matched <- div_nem_species_matched[match(pruned_tree$tip.label, names(div_nem_species_matched))]

if (!all(names(div_nem_species_matched) == pruned_tree$tip.label)) {
  stop("Error: The names in the phenotypic data do not match the tip labels in the tree.")
}

# Use contMap to plot the tree with the matched data
contMap(pruned_tree,
        div_nem_species_matched,
        res = 400,
        lwd = 4,
        outline = FALSE,
        sig = 0)
```


--------------------------------------------------


```{r}
heatmap_data <- data.frame(
  species_name = names(div_nem_species_matched),
  div = div_nem_species_matched
)

# Aggregate the data to make species names unique
heatmap_data <- heatmap_data %>%
  group_by(species_name) %>%
  summarise(div = sum(div, na.rm = TRUE)) %>%  # Adjust to your preferred method (sum, mean, etc.)
  ungroup()

# Ensure there are no missing values
heatmap_data <- heatmap_data %>%
  filter(!is.na(div))  # Remove rows with NA values

# Set the row names to the unique species names
rownames(heatmap_data) <- heatmap_data$species_name

# Plot the tree
p <- ggtree(pruned_tree) +
  geom_tiplab(align = TRUE, linesize = 0.5, offset = 0.01) +
  xlim(0, 3)  # Adjust the x-axis limits as needed

# Add the heatmap next to the tree
p1 <- gheatmap(p, heatmap_data[, "div", drop = FALSE], offset = 0.8, width = 0.1, 
               colnames = FALSE, low = "white", high = "red", legend_title = "div") +
  scale_fill_gradient(low = "white", high = "red")  # Ensures a color gradient for the fill

# Print the plot
print(p1)
```